---
title: "Geospatial Analytics for Social Good"
editor: visual
---

# Background

Water is an essential resource, providing healthy environment, a sustainable economy, reducing poverty and also ensuring peace and security. Importance of accessible and clear water is very critical, already 40% of the population doesn't have access to safe drinkable water. The scarcity of water leads to imbalance in the ecosystem. There will be food scarcity as agricultural department is dependent on world's accessible freshwater.

Scarcity of fresh water is so adverse that 80% of illness in developing countries are because of lack of sanitation and clean water. Providing clean water in rural communities of the developing countries is still a major issue in many countries globally, especially countries in Africa continent.

To address this issue a projected has been initiated with aim to collect water point related data from rural areas at the water point or small water scheme level and share the data via WPdx Data Repository, a cloud-based data library.

# Objective

To address complex problems faced by society using geospatial analysis. Using appropriate global and local measures of spatial Association techniques, the spatial patterns of Not Functional water points are revealed. In this exercise, Nigeria will be used as a study point country.

# The Data

## Aspatial Data

The data from [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/) will be used, WPdx+ data set.

## Geospatial Data

Nigeria Level-2 Administrative Boundary (also known as Local Government Area) polygon features GIS data will be used downloaded from [geoBoundaries](https://www.geoboundaries.org/).

# The Task

## Data Wrangling

Following tasks will be performed in geospatial analysis:

-   Using appropriate sf method, importing the shapefile into R and save it in a simple feature data frame format.

-   Using appropriate tidyr and dplyr methods, proportion of functional and non-functional water point at LGA level is derived.

-   Combining the geospatial and aspatial data frame into simple feature data frame.

-   Performing outliers/clusters analysis by using appropriate local measures of spatial association methods.

-   Performing hotspot areas analysis by using appropriate local measures of spatial association methods.

## Thematic Mapping

-   Maps are plotted to show the spatial distribution of functional and non-functional water point rate at LGA level by using appropriate thematic mapping technique provided by tmap package.

## Analytical Mapping

-   Hotspot areas and outliers/clusters maps of functional and non0functional water point rate at LGA level by using appropriate thematic mapping technique provided by tmap package.

# Getting Started

## Setting the Analytical Tools

Installing and launching R packages into R environment

```{R}
pacman::p_load(sf, spdep, tmap, tidyverse,funModeling)
```

## Import shapefile into R environment

### Importing water point geospatial

Using, st_read() of **sf** package, Nigeria Level-2 Administrative Boundary shapefile is imported into R environment.

```{r}
#| eval: false

wp <- st_read(dsn = "Geodata",
              layer = "geo_export",
              crs = 4326) %>%
  filter(clean_coun == "Nigeria")
```

Things to learn from the code chunk above:

\*\*st_read()\*\* of sf package is used to import geo_export shapefile into R environment and save the imported geospatial data into simple feature data table.

\*\*filter()\*\* of dplyr package is used to extract water point records of Nigeria. In the code chunk below, "write_rds()" of reader package is used to save the extracted sf table .....

Next, \`write_rds()\` of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format. The output file is called \*wp_nga.rds\* and it is saved in \*geodata\* sub-folder.

```{R}
#| eval: false
write_rds(wp, "Geodata/wp_nga.rds")
```

### Importing Nigeria LGA boundary data

Now, we are going to import the LGA boundary data into R environment by using the code chunk below.

```{R}
#| eval: false
nga <- st_read(dsn = "Geodata",
               layer= "geoBoundaries-NGA-ADM2",
               crs = 4326)
```

Thing to learn from the code chunk above.

\- \`st_read()\` of \*\*sf\*\* package is used to import \*geoBoundaries-NGA-ADM2\* shapefile into R environment and save the imported geospatial data into simple feature data table.

# Data Wrangling

## Recoding the NA values into string

In the code chunk below, \`replace_na()\` is used to recode all the \*NA\* values in \*status_cle\* field into \*Unknown\*.

```{R}
#| eval: false
wp_nga <- read_rds("geodata/wp_nga.rds") %>%
  mutate(status_cle = replace_na(status_cle, "Unknown"))
  
```

## Exploratory Data Analysis

In the code chunk below, `freq()` of **funModeling** package is used to display the distribution of *status_cle* field in *wp_nga*.

```{r}
#| eval: false
freq(data=wp_nga, 
     input = 'status_cle')
```

# Extracting Water Points

By using classes in *status_cle* field, extracting water points records.

## Extracting functional water point

Using, `filter()` of dplyr is used to select functional water points.

```{r}
#| eval: false
wpt_functional <- wp_nga %>%
  filter(status_cle %in%
           c("Functional", 
             "Functional but not in use",
             "Functional but needs repair"))
```

```{r}
#| eval: false
freq(data=wpt_functional, 
     input = 'status_cle')
```

## Extracting non-functional water points

Using, `filter()` of dplyr is used to select non-functional water points.

```{r}
#| eval: false
wpt_nonfunctional <- wp_nga %>%
  filter(status_cle %in%
           c("Abandoned/Decommissioned", 
             "Abandoned",
             "Non-Functional",
             "Non functional due to dry season",
             "Non-Functional due to dry season"))
```

```{r}
#| eval: false
freq(data=wpt_nonfunctional, 
     input = 'status_cle')
```

## Extracting water point with unknown class

Using, `filter()` of dplyr is used to select water points with unknown status.

```{r}
#| eval: false
wpt_unknown <- wp_nga %>%
  filter(status_cle == "Unknown")
```

# Performing Point-in Polygon Count

```{r}
#| eval: false
nga_wp <- nga %>% 
  mutate(`total wpt` = lengths(
    st_intersects(nga, wp_nga))) %>%
  mutate(`wpt functional` = lengths(
    st_intersects(nga, wpt_functional))) %>%
  mutate(`wpt non-functional` = lengths(
    st_intersects(nga, wpt_nonfunctional))) %>%
  mutate(`wpt unknown` = lengths(
    st_intersects(nga, wpt_unknown)))
```

# Saving the Analytical Data Table

Learnings from code chunks:

-   `mutate()` of **dplyr** package is used to derive two fields namely *pct_functional* and *pct_non-functional*.

-   to keep the file size small, `select()` of **dplyr** is used to retain only field 3,4,9,10, 18,19,20,21,22,and 23.

```{r}
#| eval: false
nga_wp <- nga_wp %>%
  mutate(pct_functional = `wpt functional`/`total wpt`) %>%
  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`)
```

```{r}
#| eval: false
write_rds(nga_wp, "Geodata/nga_wp.rds")
```

# Visualising the spatial distribution of water points

```{r}
nga_wp <- read_rds("Geodata/nga_wp.rds")
#| fig-width: 14
#| fig:height: 12
  tm_shape(nga_wp)+
  tm_fill(c("total wpt","wpt functional","wpt non-functional","wpt unknown"), 
          style = "quantile", 
          palette = "Blues") +
  tm_layout(main.title = "Distribution of Water Points",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.25, 
            legend.width = 0.35,
            legend.position = c("right", "bottom"),
            frame = TRUE) +
  tm_borders(alpha = 0.5)
```

Using maps we can observe exact number of total, non functional, non-functional and unknown spatial distribution of water points. (Figure 1)

![](images/paste-31344AB4.png){fig-align="center"}

Fig 1: Visual spatial distribution of water points

**Observations:**

Above visualization shows the spatial distribution of water points in functional, non functional and unknown classes. The darker blue shade shows that proportion of water points in the particular region is highest among all the neighboring regions.

It can be observed that cluster of Wukari, Gassol, Ardo Kola, Zing, Bali has high proportion of functional, non functional and unknown class water points.

# Thematic Mapping 

Thematic maps are the single0topic maps that focus on specific themes or phenomena. By using. ***tmap()*** package,spatial distribution of functional and non functional water point rate at LGA level can be plotted.

But for our study we will only plot the **non functional** spatial distribution of water points using the code chunk below:

```{R}
equal <- tm_shape(nga_wp) +
  tm_fill("wpt non-functional",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal interval classification")

quantile <- tm_shape(nga_wp) +
  tm_fill("wpt non-functional",
          n = 5,
          style = "quantile") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal quantile classification")

tmap_arrange(equal, 
             quantile, 
             asp=1, 
             ncol=2)
```

Left Map: It shows the equal **interval** classification of non functional spatial distribution of water points.\
Right Map: It shows the equal **quantile** classification of non functional spatial distribution of water points.

# Computing Contiguity Spatial Weights 

Global spatial autocorrelation statistics is computed and spatial complete randomness test for global spatial autocorrelation is performed.

Using **the code chunk below**, Queen contiguity weight matrix is computed:

```{R}
wm_q <- poly2nb(nga_wp, 
                queen=TRUE)
summary(wm_q)
```

In the above code chunk, **poly2nb()** of **spdep** package is used to compute contiguity weight matrices for the study area.

The summary reports shows that in Nigeria area there are 774 area units. The most number of neighbors are with 508th area unit and the least number of neighbors are with 138th and 560th area unit. There is a region, 86th with no neighbors.

```{R}
set.ZeroPolicyOption(TRUE)
```

## Row- Standardized weight matrix

In this method, each neighboring polygon will assigned with equal weights (style=\"W\"). W means sum over all links to n. It is done by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values.

There are 2 major arguments of function ***nb2listw():***

1.  ***styles*** can take values \"W\", \"B\", \"C\", \"U\", \"minmax\" and \"S\".

If *zero policy* is set to TRUE, weights vectors of zero length are inserted for regions without neighbor in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %\*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.

```{R}
rswm_q <- nb2listw(wm_q, 
                   style="W", 
                   zero.policy = TRUE)
rswm_q
```

# Global Spatial Autocorrelation: Moran's I 

Using the code chunk below, ***moran.test() from spdep,*** Moran's I statistics testing will be performed on non functional water points.

```{R}
moran.test(nga_wp$`wpt non-functional`, 
           listw=rswm_q, 
           zero.policy = TRUE, 
           na.action=na.omit)

```

The code chunk above, moran.test() is used Moran's test for spatial autocorrelation using a spatial weights matrix in weights list form.

It can be observed that Z value, 0.433, is greater than zero. Therefore, it can be concluded non functional spatial distribution of water points are clusters and observations tend to be similar.

## Computing Monte Carlo's Moran's I

Monte Carlo simulation is performed when there is a doubt that the assumptions of Moran\'s I are true (normality and randomization).

The code chunk below performs permutation test for Moran\'s I statistic by using **m*oran.mc()*** of **spdep**. A total of 1000 simulation will be performed.

nsim is set as 999 for 1000 simulations as 0 is also included.

```{R}
set.seed(1234)
bperm= moran.mc(nga_wp$`wpt non-functional`, 
                listw=rswm_q, 
                nsim=999, 
                zero.policy = TRUE, 
                na.action=na.omit)
bperm
```

From the above results, we can observe p value is less than significant level of 0.05. Therefore, we can **reject** the null hypothesis,Observed spatial pattern of values is equally likely as any other spatial pattern.

## Visualizing Monte Carlo Moran's I 

Monte Carlo Moran's I statistics testing will be visualized by plotting the distribution of the statistical values as a histogram by using the code chunk below:

In the code chunk below ***hist()*** and ***abline()*** of R Graphics are used.

```{R}
mean(bperm$res[1:999])
```

```{R}
var(bperm$res[1:999])
```

```{R}
summary(bperm$res[1:999])
```

```{R}
hist(bperm$res, 
     freq=TRUE, 
     breaks=20, 
     xlab="Simulated Moran's I")
abline(v=0, 
       col="red") 
```

Learnings from above code chunk :

**hist()** -computes a histogram of the given data values.

**abline()-** This function adds one or more straight lines through the current plot

From the above histogram, it can interpreted that at Simulated Moran's I value 0 then frequency of non functional spatial water distribution points are maximum.

# Spatial Correlogram 

Spatial correlogram are great to examine the patterns of spatial autocorrelation in the data or model residual.

They show how correlated are pairs of spatial observations when you increase the distance (lag) between them - they are plots of some index of autocorrelation (Moran\'s I) against distance.

## Compute Moran's I Correlogram 

Computation of 6-lag spatial correlogram of non functional water points. The global spatial autocorrelation used in Moran\'s I. The **plot()** of base Graph is then used to plot the output.

```{R}
MI_corr <- sp.correlogram(wm_q, 
                          nga_wp$`wpt non-functional`, 
                          order=6, 
                          method="I", 
                          style="W")
plot(MI_corr)
```

Above plot might not provide complete interpretation as not all autocorrelation values are statistically significant. Therefore, full analysis report is printed using the below code chunk.

```{R}
print(MI_corr)
```

From the above output, it can be observed that all the 6 lag spatial correlogram, p value is less than the significant value of 0.05. Therefore null hypothesis, the non functional water points location of values may be altered without affecting the information content of the data, is **rejected**.

# Cluster and Outlier Analysis 

 Local Indicators of Spatial Association or LISA are statistics that evaluate the existence of clusters in the spatial arrangement of a given variable. We are studying non functional spatial distribution of water points among census tracts in a Nigeria, local clusters in the rates mean that there are areas that have higher or lower rates than is to be expected by chance alone; that is, the values occurring are above or below those of a random distribution in space.

## Computing local Moran's I

Computing local Moran\'s I of *non functional water points* at the county level using **localmoran() function in spdep.**

```{R}
fips <- order(nga_wp$shapeName)
localMI <- localmoran(nga_wp$`wpt non-functional`, rswm_q)
head(localMI)
```

localmoran() function returns a matrix of values whose columns are:

-   Ii: the local Moran\'s I statistics

-   E.Ii: the expectation of local moran statistic under the randomisation hypothesis

-   Var.Ii: the variance of local moran statistic under the randomisation hypothesis

-   Z.Ii:the standard deviate of local moran statistic

-   Pr(): the p-value of local moran statistic

List the content of the local Moran matrix derived by using *printCoefmat()*

## Mapping the Local Moran's I

Before mapping, append the local Moran\'s I dataframe (i.e. localMI) onto nga_wp SpatialPolygonDataFrame

```{R}
nga_wp.localMI <- cbind(nga_wp,localMI) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

```{R}
tm_shape(nga_wp.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty",
          palette = "RdBu",
          title = "local moran statistics") +
  tm_borders(alpha = 0.5)
```

## Mapping local Moran's I p values

As li has both positive and negative values, therefore it is useful to consider p values for each of these values:

```{R}
tm_shape(nga_wp.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Blues", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5)
```

## 
Mapping both local Moran's I values and p values 

Both the maps are plotted together for in depth comparison analysis.

```{R}
localMI.map <- tm_shape(nga_wp.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty", 
          title = "local moran statistics") +
  tm_borders(alpha = 0.5)

pvalue.map <- tm_shape(nga_wp.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Blues", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5)

tmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)
```

# 
Creating LISA Cluster Map 

##  

\





\

